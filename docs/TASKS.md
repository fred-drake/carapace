# Carapace Development Tasks

> Master task list generated by the AI planning team (2026-02-18).
> Updated after full team review (2026-02-18) — 6-role review incorporated.
> Organized by priority tier, then by role. Tasks reference each other by ID.

## Legend

- **P0** = Must build first (foundational, blocks everything)
- **P1** = Build next (core functionality, blocks features)
- **P2** = Build after core works (features, polish, hardening)
- **Complexity**: S (hours), M (1-2 days), L (3-5 days), XL (1+ week)

---

## P0 — Foundation

These tasks must be completed first. They establish the project skeleton, messaging
backbone, core routing, test infrastructure, and CI pipeline that everything else
depends on.

### ~~ARCH-01: Bootstrap project structure~~ DONE

**Status**: Completed (PR #1, merged 2026-02-18)
**Role**: Architect / Engineer
**Description**: Initialize package.json, tsconfig.json (strict mode), pnpm workspace
config, and directory layout: `src/core/`, `src/ipc/`, `src/plugins/`, `src/types/`,
`src/container/`. Configure path aliases and module resolution.
**Dependencies**: None
**Acceptance criteria**: `pnpm install && pnpm run build` succeeds with zero source
files. TypeScript strict mode enabled. ESM module system configured.
**Complexity**: S

### ~~ARCH-02: Define message envelope types~~ DONE

**Status**: Completed (PR #5, merged 2026-02-18)
**Role**: Architect / Engineer
**Description**: Create TypeScript interfaces for the full message protocol:
`WireMessage` (topic, correlation, arguments), `Envelope` (id, version, type, topic,
source, correlation, timestamp, group, payload), `EventPayload`, `RequestPayload`,
`ResponsePayload`. Define the `Topic` string literal union type from the topic
hierarchy. Define all 10 error code enums (`UNKNOWN_TOOL`, `VALIDATION_FAILED`,
`UNAUTHORIZED`, `RATE_LIMITED`, `CONFIRMATION_TIMEOUT`, `CONFIRMATION_DENIED`,
`PLUGIN_TIMEOUT`, `PLUGIN_UNAVAILABLE`, `PLUGIN_ERROR`, `HANDLER_ERROR`).
**Dependencies**: ARCH-01
**Acceptance criteria**: All message types compile. Wire format and envelope types have
zero overlap (enforced by type system). Topic hierarchy covers all documented topics.
All 10 error codes are defined with `retriable`, `stage`, `field`, and `retry_after`
metadata where applicable.
**Complexity**: M

### ~~ARCH-03: Define plugin manifest schema and types~~ DONE

**Status**: Completed (PR #6, merged 2026-02-18)
**Role**: Architect / Engineer
**Description**: Create TypeScript interfaces and JSON Schema for plugin manifests:
tool declarations (name, description, risk_level, argument schema), hook subscriptions,
and configuration schema. The manifest schema itself must enforce
`additionalProperties: false`.
**Dependencies**: ARCH-01
**Acceptance criteria**: A sample manifest validates correctly. Invalid manifests are
rejected with clear errors. TypeScript types match the JSON Schema.
**Complexity**: M

### ~~ENG-01: Implement ZeroMQ PUB/SUB event bus~~ DONE

**Status**: Completed (PR #13, merged 2026-02-18)
**Role**: Engineer
**Description**: Build the event bus using ZeroMQ PUB/SUB pattern over Unix domain
sockets. Core runs a PUB socket; plugins and container subscribe by topic prefix.
Support topic-based filtering. Handle socket lifecycle (bind, connect, close,
reconnect).
**Dependencies**: ARCH-01, ARCH-02
**Test requirements**: QA-01, QA-03. Test: topic filtering, multi-subscriber delivery,
unsubscribed topic exclusion, socket cleanup, reconnection after failure.
**Acceptance criteria**: Events published on a topic are received by all subscribers
to that topic. Unsubscribed topics are not received. Socket cleanup on shutdown is
clean (no lingering files).
**Complexity**: M

### ~~ENG-02: Implement ZeroMQ ROUTER/DEALER request channel~~ DONE

**Status**: Completed (PR #14, merged 2026-02-18)
**Role**: Engineer
**Description**: Build the request-response channel using ZeroMQ ROUTER/DEALER pattern.
Core runs ROUTER; agent and plugins connect as DEALERs. Core routes requests by topic
prefix to the correct plugin DEALER. Correlation IDs link requests to responses.
**Dependencies**: ARCH-01, ARCH-02
**Test requirements**: QA-01, QA-03. Test: correlation matching, concurrent requests,
unknown topic errors, timeouts, connection identity tracking.
**Acceptance criteria**: A DEALER sends a request and receives the correct response
matched by correlation ID. Requests to unknown topics return error responses. Multiple
concurrent requests are handled correctly.
**Complexity**: L

### ~~ENG-03: Implement core message router~~ DONE

**Status**: Completed (PR #18, merged 2026-02-18)
**Role**: Engineer
**Description**: Build the central router that receives messages from both channels,
constructs full envelopes from wire messages (adding id, version, type, source, group,
timestamp from session state), validates messages, and dispatches to the correct
handler or plugin. Implement the 6-stage validation pipeline incrementally via TDD:
Stage 1 (envelope construction) first, then Stages 2–6. This is the heart of the
system.
**Dependencies**: ENG-01, ENG-02, ARCH-02
**Test requirements**: QA-01, QA-02, QA-03. Test each pipeline stage individually:
envelope construction from wire+session, topic validation, payload validation, auth
check, rate limit, dispatch. Test malformed input does not crash.
**Acceptance criteria**: Wire messages from container are enriched into full envelopes.
Messages are routed to correct plugins by topic. Invalid messages are rejected with
appropriate error codes. Router does not crash on malformed input. Each of the 6
pipeline stages is independently testable.
**Complexity**: L

### ~~ENG-04: Implement plugin loader~~ DONE

**Status**: Completed (PR #19, merged 2026-02-18)
**Role**: Engineer
**Description**: Build the filesystem-based plugin discovery and loading system. Scan
`plugins/` directory at startup, parse and validate each manifest.json, instantiate
plugin handlers, register their tools in the router's dispatch table, and manage plugin
lifecycle (init, ready, shutdown). Handle initialization failures gracefully — failed
plugins are excluded from tool catalog and reported via `get_session_info`.
**Dependencies**: ARCH-03, ENG-03
**Test requirements**: QA-01, QA-02. Test: discovery (mock FS), manifest parse/reject,
handler lifecycle (init/ready/shutdown order), tool name collision detection, init
failure degradation, 10-point initialization failure behavior.
**Acceptance criteria**: Plugins in `plugins/` are auto-discovered and loaded. Invalid
manifests produce clear error messages and don't crash the system. Plugin tools are
routable after loading. Plugin lifecycle hooks fire in correct order. Failed plugins
are excluded from catalog, not from the system.
**Complexity**: L

### ~~QA-01: Set up test framework~~ DONE

**Status**: Completed (PR #7, merged 2026-02-18)
**Role**: QA
**Description**: Configure Vitest with TypeScript support, path alias resolution
matching tsconfig, and coverage reporting (v8 provider). Set up test directory
structure mirroring `src/`. Configure CI-friendly output format. Add test scripts
to package.json: `test`, `test:coverage`, `test:integration` (tagged), `test:security`
(tagged), `test:e2e` (tagged, Docker-required).
**Dependencies**: ARCH-01
**Acceptance criteria**: `pnpm test` runs unit tests. `pnpm test -- <path>` runs a
single file. `pnpm test:coverage` generates reports. `pnpm test:integration` runs
integration-tagged tests only. Vitest config handles TypeScript and path aliases.
**Complexity**: S

### ~~QA-02: Build test fixtures and factories~~ DONE

**Status**: Completed (PR #15, merged 2026-02-18)
**Role**: QA
**Description**: Create factory functions for common test objects: `createWireMessage()`,
`createEnvelope()`, `createManifest()`, `createPluginConfig()`, `createTestDatabase()`
(in-memory SQLite via better-sqlite3 `:memory:`), `createMemoryEntryFixture()`. These
produce valid defaults that can be overridden per-test. Avoids brittle tests coupled
to exact object shapes.
**Dependencies**: QA-01, ARCH-02, ARCH-03
**Acceptance criteria**: Factories produce valid objects that pass schema validation.
Any field can be overridden. Factories are typed — TypeScript catches invalid overrides
at compile time. SQLite test helpers create in-memory DBs with migrations applied.
**Complexity**: S

### ~~QA-03: Build ZeroMQ mock infrastructure~~ DONE

**Status**: Completed (PR #11, merged 2026-02-18)
**Role**: QA
**Description**: Create mock/fake ZeroMQ sockets for unit testing: `FakePubSocket`,
`FakeSubSocket`, `FakeRouterSocket`, `FakeDealerSocket`. These capture sent messages
and can be programmed to deliver responses. Avoid real socket I/O in unit tests.
Simulate failure modes: connection refused, socket timeout, message too large.
**Dependencies**: QA-01
**Acceptance criteria**: Unit tests using fake sockets run without real ZeroMQ. Fakes
capture all sent messages for assertion. Fakes can simulate responses, errors, and
timeouts. Fakes simulate failure modes (refused, timeout, oversized). API mirrors real
zeromq.js closely enough that tests are meaningful.
**Complexity**: M

### ~~QA-09: Build mock container runtime~~ DONE

**Status**: Completed (PR #12, merged 2026-02-18)
**Role**: QA
**Description**: Create a mock container runtime for testing session manager (ENG-06),
container lifecycle manager (DEVOPS-03), and container-related code without Docker.
The mock simulates: container spawn (returns mock connection identity), ZeroMQ
connection establishment, graceful and forced shutdown, resource cleanup verification.
Enables unit testing of container-adjacent code in CI without Docker.
**Dependencies**: QA-01
**Acceptance criteria**: Unit tests for session manager and lifecycle manager run
without Docker. Mock can simulate spawn failures, timeout, and crash scenarios.
Cleanup verification confirms no leaked resources.
**Complexity**: M

### ~~QA-10: Build IPC binary test harness~~ DONE

**Status**: Completed (PR #17, merged 2026-02-18)
**Role**: QA
**Description**: Create a test harness specifically for the `ipc` binary (ENG-05). The
binary is the container's sole communication channel — it must be thoroughly tested.
Harness tests: argument parsing, wire message construction, correlation ID generation,
timeout behavior, exit code semantics, stdout/stderr output formatting. Uses fake
ZeroMQ sockets from QA-03.
**Dependencies**: QA-01, QA-03
**Acceptance criteria**: IPC binary can be tested in isolation with fake sockets. All
error paths have tests. Exit codes are verified. Wire message construction is validated
against ARCH-02 types.
**Complexity**: S

### ~~DEVOPS-01: Create container Dockerfile~~ DONE

**Status**: Completed (PR #8, merged 2026-02-18)
**Role**: DevOps
**Description**: Build a multi-stage Dockerfile for the agent container. Build stage
compiles the `ipc` binary from TypeScript. Runtime stage uses Node.js 22 base with
read-only root filesystem. Copy only the compiled `ipc` binary and skill markdown
files. No package managers, no network tools, no credentials. Writable mounts for
workspace, `.claude/`, and ZeroMQ socket path. Define image tagging strategy
(git SHA + semantic version).
**Dependencies**: ARCH-01
**Acceptance criteria**: Container builds successfully via multi-stage build. Root
filesystem is read-only. No network access from inside container. Only `ipc` binary
is executable. Writable mounts work for workspace and socket. Image tags follow
versioning strategy.
**Complexity**: M

### ~~DEVOPS-02: Configure CI pipeline~~ DONE

**Status**: Completed (PR #9, merged 2026-02-18)
**Role**: DevOps
**Description**: Set up GitHub Actions CI with a multi-stage pipeline designed for
fast feedback first, security scanning second, integration tests last. See the
CI Pipeline Design section below for full stage breakdown and quality gates.
**Dependencies**: ARCH-01, QA-01
**Acceptance criteria**: CI runs on push/PR with all quality gates. Stages run in
correct order with parallelization within stages. Merge is blocked on: lint errors,
type errors, unit test failures, coverage below thresholds, Semgrep high/critical
findings, CodeQL high/critical findings. Cache node_modules and Nix store. Pipeline
completes in under 10 minutes for PR checks.
**Complexity**: L

---

## P1 — Core Functionality

These tasks build on the foundation to deliver a working system that can run an agent
session end-to-end, with full validation, error handling, and testing.

### ENG-05: Build IPC binary (container-side CLI)

**Role**: Engineer
**Description**: Implement the `ipc` CLI tool that runs inside the container. It
accepts tool invocation arguments from Claude Code (via Bash), constructs a wire
message (topic, correlation, arguments), sends it to the host via ZeroMQ DEALER
socket, waits for the response, and prints the result to stdout. This is the
container's only way to communicate with the host.
**Dependencies**: ENG-02, ARCH-02
**Note**: Does NOT depend on ENG-03 or ENG-04. Can be built in parallel with the
core router, shortening the critical path.
**Test requirements**: QA-10 (IPC test harness), QA-03 (fake sockets). Test: CLI arg
parsing, wire message construction, correlation generation, timeout, exit codes,
stdout/stderr formatting.
**Acceptance criteria**: `ipc tool.invoke.create_reminder '{"title":"test"}'` sends a
valid wire message and prints the response. Correlation IDs are generated per
invocation. Timeout on no response. Exit codes reflect success/failure.
**Complexity**: M

### ENG-06: Implement session manager

**Role**: Engineer
**Description**: Build the session manager that tracks active agent sessions: which
container is running, which group it belongs to, session start time, and the ZeroMQ
connection identity for that session. The router uses this to construct envelope
identity fields from trusted state.
**Dependencies**: ENG-03
**Test requirements**: QA-01, QA-02, QA-09 (mock container runtime). Test: session
CRUD, connection→session mapping, concurrent session isolation, cleanup on teardown.
**Acceptance criteria**: Sessions are created when containers spawn and destroyed on
teardown. Router can look up group/source from connection identity. Concurrent sessions
for different groups are isolated.
**Complexity**: M

### ENG-07: Implement schema validation engine

**Role**: Engineer
**Description**: Build a validation layer that validates tool arguments against their
declared JSON Schemas (from plugin manifests). Enforce `additionalProperties: false`
on all schemas. Produce clear validation error messages with the JSON path to the
invalid field. Uses ajv.
**Dependencies**: ARCH-03
**Test requirements**: QA-01. Test: valid/invalid schemas, additionalProperties
rejection, nested field validation, error path formatting with JSON pointer, prototype
pollution keys (`__proto__`, `constructor`) handling.
**Acceptance criteria**: Valid arguments pass validation. Extra properties are rejected.
Missing required fields are caught. Error messages include the JSON path to the problem.
Prototype pollution keys are safely handled.
**Complexity**: M

### ENG-08: Implement SQLite data layer

**Role**: Engineer
**Description**: Build the SQLite connection manager and migration system. Support
per-feature, per-group databases at `data/{feature}/{group}.sqlite`. Migrations are
TypeScript files run in order. Connection pooling is not needed (better-sqlite3 is
synchronous). Validate group names against `[a-zA-Z0-9_-]` to prevent path traversal.
**Dependencies**: ARCH-01
**Test requirements**: QA-01, QA-02 (SQLite test helpers). Test: connection
create/reuse, migration ordering, idempotent migrations, per-feature/per-group path
resolution, group name validation rejects traversal patterns. Use in-memory SQLite.
**Acceptance criteria**: Databases are created on first access at the correct path.
Migrations run in order and are idempotent. Schema changes are versioned. Connection
handles are reused within a session. Group names with `../` or invalid characters
are rejected.
**Complexity**: M

### ENG-09: Build skill file loader

**Role**: Engineer
**Description**: Implement the system that reads container-side skill markdown files
from `plugins/{name}/skills/` and prepares them for injection into the container's
`.claude/` directory. Also auto-generate skill files for core intrinsic tools. Skills
teach Claude what tools are available.
**Dependencies**: ENG-04
**Test requirements**: QA-01. Test: discovery from plugin dirs, content reading,
missing file warnings (not crashes), auto-generation for intrinsic tools.
**Acceptance criteria**: Skill files are discovered from plugin directories. Skills are
collected and prepared for container mount. Missing skill files produce warnings, not
crashes. Intrinsic tool skills are auto-generated.
**Complexity**: S

### ENG-14: Implement core intrinsic tools

**Role**: Engineer
**Description**: Implement the three core intrinsic tools documented in ARCHITECTURE.md:
`get_diagnostics` (query session-scoped audit log by correlation ID or recent errors),
`list_tools` (enumerate available tools with descriptions and risk levels),
`get_session_info` (return current group, session start time, plugin health with
healthy/failed categories). These are compiled into the core, registered in the same
tool catalog as plugin tools, and go through the full 6-stage validation pipeline.
**Dependencies**: ENG-03, ENG-06, ENG-17
**Test requirements**: QA-01, QA-02. Test: all three tools invokable via standard
pipeline, `list_tools` returns intrinsic + plugin tools, `get_session_info` shows
plugin health categories, `get_diagnostics` filters by correlation ID.
**Acceptance criteria**: All three tools are invokable via `ipc tool.invoke.{name}`.
`list_tools` returns all registered plugin and intrinsic tools. `get_session_info`
includes plugin health status (healthy + failed with error category). `get_diagnostics`
queries audit log entries. Tools pass full validation pipeline.
**Complexity**: M

### ENG-15: Implement user confirmation gate (Stage 5)

**Role**: Engineer
**Description**: Build the user confirmation mechanism for `risk_level: "high"` tools.
When a tool invocation reaches Stage 5 of the validation pipeline, the core pauses
execution and surfaces the request for user approval (through the channel that
initiated the session, or a default approval channel). Handle confirmation timeout
(configurable, default 5 minutes → `CONFIRMATION_TIMEOUT`) and explicit denial
(`CONFIRMATION_DENIED`). Clean up pending confirmation state on timeout/denial.
**Dependencies**: ENG-03, SEC-01
**Test requirements**: QA-01, QA-02. Test: high-risk tools pause, approval proceeds,
denial returns CONFIRMATION_DENIED, timeout returns CONFIRMATION_TIMEOUT, low-risk
tools bypass entirely, pending state cleanup.
**Acceptance criteria**: High-risk tool invocations pause for user confirmation.
Approved requests proceed to Stage 6. Denied requests return `CONFIRMATION_DENIED`.
Timed-out requests return `CONFIRMATION_TIMEOUT`. Low-risk tools bypass this stage.
**Complexity**: L

### ENG-16: Implement core services interface

**Role**: Engineer
**Description**: Build the `CoreServices` interface that plugin handlers receive during
`initialize()`: `getAuditLog(filters)`, `getToolCatalog()`, `getSessionInfo()`.
Implement automatic group-scoping using `AsyncLocalStorage` (or equivalent) so handlers
never pass group/session IDs — the core manages request context internally.
`getAuditLog` accepts `correlation`, `topic`, `outcome`, `last_n`, and time ranges
but never `group` or `sessionId` as filter keys.
**Dependencies**: ENG-03, ENG-06, ENG-17
**Test requirements**: QA-01, QA-02. Test: services are group-scoped automatically,
getAuditLog never returns cross-group entries, TypeScript autocomplete works.
**Acceptance criteria**: Handlers receive a `services` object at init. Core services
are automatically scoped to the group of the current request. `getAuditLog` never
returns entries from other groups. TypeScript provides full autocomplete.
**Complexity**: M

### ENG-17: Implement audit log subsystem

**Role**: Engineer
**Description**: Build the host-side audit log system. Structured JSON Lines format,
one object per line. Each entry includes: timestamp, group, source, topic, correlation,
stage, and outcome (`routed`, `rejected`, `sanitized`, `error`). Validation rejections
include the stage that failed and reason. Response sanitization events log field paths
affected (not redacted values). Handler errors log two entries per error (before and
after normalization), linked by correlation ID. Storage at `data/audit/`.
**Dependencies**: ENG-03
**Test requirements**: QA-01. Test: every message type is logged, rejection entries
include stage and reason, sanitization events logged, dual-entry handler error logging,
structured JSON Lines format, queryable by correlation ID.
**Acceptance criteria**: Every message crossing the trust boundary is logged. Rejection
entries include stage and reason. Sanitization events are logged. Dual-entry handler
error logging works. Logs are structured JSON Lines. Logs are queryable by correlation
ID for `get_diagnostics`.
**Complexity**: M

### ENG-18: Implement ToolError class and error response handling

**Role**: Engineer
**Description**: Implement the `ToolError` class exported from `@carapace/sdk`. Build
the core's error discrimination logic: return values → success response, `ToolError`
throws → structured error response, other throws → generic `PLUGIN_ERROR` (no
internals leaked), handler timeout → `PLUGIN_TIMEOUT`. Implement all 10 documented
error codes. Enforce response payload size limits (default 1MB). Ensure error responses
pass through the full Response Path (Sanitize → Log → Forward).
**Dependencies**: ARCH-02, ENG-03
**Test requirements**: QA-01, QA-02. Test: all 10 error codes produce correct envelopes,
instanceof ToolError discrimination works, non-ToolError throws produce generic
PLUGIN_ERROR, error responses are sanitized, oversized responses produce HANDLER_ERROR.
Test instanceof edge cases: plain object with ToolError fields, different module
instance, `__proto__` manipulation.
**Acceptance criteria**: All 10 error codes are implemented. `instanceof ToolError`
discrimination works. Non-ToolError throws produce generic `PLUGIN_ERROR`. Error
responses are sanitized. Oversized responses produce `HANDLER_ERROR`. Error codes
include correct metadata (`retriable`, `stage`, `field`, `retry_after`).
**Complexity**: M

### ENG-19: Implement event-to-agent decision logic

**Role**: Engineer
**Description**: Build the core's logic for deciding when PUB/SUB events warrant
spawning a new agent container. `message.inbound` events spawn an agent if the group
matches a configured group. `task.triggered` events always spawn an agent with the
task prompt. Other event types are logged but do not spawn agents. Handle the case
where a session is already active for a group (queue, reject, or run concurrent —
configurable).
**Dependencies**: ENG-01, ENG-06, DEVOPS-03
**Test requirements**: QA-01, QA-02, QA-09 (mock container runtime). Test: inbound
events for configured groups spawn containers, unmatched groups are dropped,
task.triggered always spawns, concurrent session policy is enforced.
**Acceptance criteria**: `message.inbound` events for configured groups spawn agent
containers. `task.triggered` events spawn agents with the task prompt. Unmatched groups
are logged and dropped. Concurrent session policy is configurable.
**Complexity**: M

### SEC-01: Implement host-side message validation

**Role**: Security
**Description**: Build the validation pipeline that every message from the container
passes through: schema validation (JSON Schema), topic whitelist check (only declared
tools), group authorization (session group matches target), and rate limiting. This is
the real security layer — the secondary boundary after container isolation.
**Dependencies**: ENG-03, ENG-06, ENG-07, SEC-03
**Test requirements**: QA-01, QA-02, QA-04 (integration harness). Test each stage
independently: schema validation rejects bad args, topic whitelist rejects unknown
tools, group auth blocks cross-group, rate limiter throttles floods. All rejections
produce correct error codes and are logged.
**Acceptance criteria**: Messages with invalid schemas are rejected. Messages to
undeclared topics are rejected. Cross-group access attempts are blocked. Rate-limited
sessions receive throttle errors. All rejections are logged with stage and reason.
**Complexity**: L

### SEC-02: Implement response sanitization

**Role**: Security
**Description**: Build a sanitization pass that scrubs plugin responses before they're
forwarded to the container. Strip common credential patterns: Bearer tokens, API keys
(X-API-Key, sk-\*, etc.), OAuth tokens, connection strings. Implement as part of the
3-stage Response Path: Sanitize → Log → Forward. Defense-in-depth against plugin
authors accidentally leaking secrets.
**Dependencies**: ENG-03, ENG-17
**Test requirements**: QA-01. Test: Bearer tokens sanitized, API key patterns caught,
sanitization doesn't corrupt valid data, sanitization events logged with field paths.
**Acceptance criteria**: Responses containing Bearer tokens are sanitized. Common API
key patterns are caught. Sanitization doesn't corrupt valid response data. Sanitization
events are logged for audit. Full Response Path (Sanitize → Log → Forward) works.
**Complexity**: M

### SEC-03: Implement rate limiter

**Role**: Security
**Description**: Build a per-session and per-group rate limiter for tool invocations.
Configurable limits (requests per minute, burst size). Token bucket or sliding window
algorithm. Rate limit state lives in memory (not SQLite — ephemeral by design).
**Dependencies**: ENG-06
**Test requirements**: QA-01. Test: sessions exceeding limit get throttle error, limits
configurable per group, burst handling works, state resets on session teardown,
accuracy under concurrent load (±5% at boundary).
**Acceptance criteria**: Sessions exceeding the rate limit receive throttle error
responses with `retry_after`. Limits are configurable per group. Burst handling works
correctly. Rate limit state resets on session teardown.
**Complexity**: M

### SEC-07: Implement container security verification

**Role**: Security / DevOps
**Description**: Verify that the built container enforces all security constraints
claimed in the architecture. Distinct from DEVOPS-01 (which builds it) — this task
_validates_ it. Tests verify: (1) root filesystem is read-only, (2) no network access
(attempt DNS, HTTP, raw socket), (3) only `ipc` binary is executable, (4)
settings.json is read-only, (5) skill files and CLAUDE.md are read-only, (6) writable
mounts limited to workspace, `.claude/` session dirs, and ZeroMQ socket, (7) no
package managers or shells beyond required.
**Dependencies**: DEVOPS-01, DEVOPS-03, DEVOPS-10
**Test requirements**: Automated test suite that spins up a container and attempts each
prohibited action. Runs in CI alongside QA-06 (Docker-required).
**Acceptance criteria**: Each prohibited action is tested and proven to fail. Tests run
in CI. Any regression in container security is immediately caught.
**Complexity**: M

### SEC-08: Implement message size limits and DoS prevention

**Role**: Security / Engineer
**Description**: Implement and test message size limits at the trust boundary: (1)
maximum wire message size (reject before JSON parsing to prevent memory exhaustion),
(2) maximum request payload size (1MB default, configurable), (3) maximum response
payload size (1MB), (4) maximum argument string length per field, (5) maximum JSON
depth to prevent stack overflow in parser.
**Dependencies**: ENG-03
**Test requirements**: QA-01. Test: oversized messages rejected before full parsing,
deeply nested JSON rejected, all limits configurable, boundary conditions covered.
**Acceptance criteria**: Messages exceeding size limits are rejected before full
parsing. Deeply nested JSON (100+ levels) is rejected. All limits are configurable.
Tests cover boundary conditions.
**Complexity**: M

### SEC-10: Implement plugin manifest security validation

**Role**: Security
**Description**: Security-harden the manifest loading process beyond ARCH-03's schema
validation: (1) validate all `arguments_schema` objects contain
`additionalProperties: false`, (2) limit schema complexity (max depth, max properties,
no recursive `$ref` for validator DoS), (3) validate skill file paths don't contain
path traversal (`../`), (4) validate tool names against allowed characters (prevent
injection through topic strings), (5) enforce maximum manifest file size.
**Dependencies**: ARCH-03, ENG-04
**Test requirements**: QA-01. Test each attack vector: missing additionalProperties,
recursive $ref, path traversal in skill paths, special chars in tool names.
**Acceptance criteria**: Manifests missing `additionalProperties: false` on any tool
schema are rejected at startup with clear error. Path traversal is blocked. Recursive
schemas are detected. Tests cover each vector.
**Complexity**: M

### DEVOPS-03: Implement container lifecycle manager

**Role**: DevOps
**Description**: Build the system that spawns agent containers on demand, manages
their lifecycle (start → running → shutdown), handles graceful and forced termination,
and cleans up resources (ZeroMQ sockets, temp files) on teardown. Detect and terminate
orphaned containers on host restart. Initially Docker-based.
**Dependencies**: DEVOPS-01, ENG-06
**Test requirements**: QA-09 (mock container runtime). Test: spawn, graceful shutdown,
forced kill after 10s timeout, resource cleanup, orphan detection on startup.
**Acceptance criteria**: Containers spawn with correct mounts and isolation. Graceful
shutdown signals are sent before forced kill. ZeroMQ sockets are cleaned up. Container
logs are captured. Stale/orphaned containers are detected and cleaned on startup.
**Complexity**: L

### DEVOPS-04: Implement ZeroMQ socket provisioning

**Role**: DevOps
**Description**: Build the system that creates, configures, and manages ZeroMQ Unix
domain sockets. Handle socket file creation, permissions, cleanup on shutdown, and
mounting into containers. Ensure sockets are only accessible by the host process and
the target container. Detect socket path collisions for concurrent sessions.
**Dependencies**: ENG-01, ENG-02, DEVOPS-01
**Acceptance criteria**: Socket files are created with restricted permissions. Sockets
are mounted into containers at the correct path. Stale socket files are cleaned up on
startup. Socket paths are configurable. Collisions for concurrent sessions are handled.
**Complexity**: M

### DEVOPS-07: Create Docker Compose for local development

**Role**: DevOps
**Description**: Create a `docker-compose.yml` that orchestrates the host core process
and agent container for local testing. Developers need a one-command way to spin up the
full system. Includes volume mounts for live-reload of skill files, socket sharing via
shared volume, and a dev network (bridge, no external access for the container).
**Dependencies**: DEVOPS-01, ENG-03
**Acceptance criteria**: `docker compose up` launches the full system. Skill file
changes are reflected without rebuild. Socket sharing works. Container has no external
network access. Developer can observe message flow.
**Complexity**: S

### DEVOPS-08: Add container build and scan to CI

**Role**: DevOps
**Description**: Extend CI pipeline to build the container image, scan it for OS-level
vulnerabilities (Trivy), and run a container smoke test (starts, filesystem is
read-only, network is unreachable, only `ipc` is executable). Optionally publish the
image to a registry on tagged releases.
**Dependencies**: DEVOPS-01, DEVOPS-02
**Acceptance criteria**: CI builds container image. Trivy scan runs and reports
vulnerabilities. Smoke test validates container constraints. High/critical Trivy
findings block merge.
**Complexity**: M

### DEVOPS-10: Implement container permission lockdown (Layer 2)

**Role**: DevOps
**Description**: Generate and mount the Claude Code `settings.json` file as a read-only
overlay in the container at `/home/node/.claude/settings.json`. This file restricts
Bash commands to only the `ipc` binary. Also mount `CLAUDE.md` (agent instructions)
and `skills/` directory as read-only overlays. The writable `.claude/` directory mount
must NOT override the read-only `settings.json` overlay.
**Dependencies**: DEVOPS-01
**Acceptance criteria**: `settings.json` is read-only inside the container. Claude
Code's Bash is restricted to `ipc` only. Agent cannot modify `settings.json`,
`CLAUDE.md`, or skill files. The `ipc` binary cannot be overwritten. `.claude/`
subdirectories for session data are writable.
**Complexity**: M

### DX-01: Define plugin handler interface

**Role**: DX Advocate
**Description**: Design and implement the TypeScript interface that all plugin handlers
must implement: `init(services: CoreServices)`, `handleToolInvocation(tool, args,
context)`, `shutdown()`. Include typed context (group, session, correlation). Export as
a public API for plugin authors. Define actionable error message template standard:
`[COMPONENT] Error: {what}. Fix: {how}. Docs: {link}`.
**Dependencies**: ARCH-03, ARCH-02
**Acceptance criteria**: Interface is clear and minimal. TypeScript provides full
autocomplete for plugin authors. Context includes all necessary fields. A sample "echo"
plugin can be written in under 30 lines and ships as `examples/echo-plugin/`. Error
message template is documented and enforced.
**Complexity**: M

### DX-02: Build CLI entry point

**Role**: DX Advocate
**Description**: Implement the main `carapace` CLI with subcommands: `start` (launch
core + container), `stop` (graceful shutdown), `status` (show running sessions),
`doctor` (check dependencies and configuration). Use a CLI framework (commander or
yargs).
**Dependencies**: ENG-03, DEVOPS-03
**Acceptance criteria**: `carapace start` launches the system. `carapace stop` shuts
down gracefully. `carapace status` shows active sessions. `carapace doctor` reports
missing dependencies.
**Complexity**: M

### DX-06: Build plugin test SDK

**Role**: DX Advocate
**Description**: Build a lightweight SDK for plugin authors to unit test their handlers
in isolation — no ZeroMQ, no running core, no containers. Includes:
`createTestContext(overrides?)` for mock PluginContext, `createTestInvocation(tool,
args)` to simulate tool calls against a handler, `FakeCredentialStore` for testing
without real secrets, response assertion helpers to verify shape and check for
accidental credential leakage.
**Dependencies**: DX-01, QA-02
**Acceptance criteria**: Plugin authors can
`import { createTestContext, createTestInvocation } from '@carapace/testing'` and
write a handler unit test in under 20 lines. No real ZeroMQ or core process needed.
**Complexity**: M

### QA-04: Build integration test harness

**Role**: QA
**Description**: Create a test harness that spins up real ZeroMQ sockets (in-process,
not Docker) for integration testing. Support sending wire messages and asserting on
envelope construction, routing, and responses. Include helpers for plugin registration
and session simulation. Cover: full 6-stage validation pipeline traversal, Response
Path testing (sanitize → log → forward), event bus → spawn decision logic (mock
container runtime), plugin initialization failure degradation, shutdown sequence
(drain → shutdown → cleanup).
**Dependencies**: QA-01, QA-03, QA-09, ENG-01, ENG-02, ENG-03
**Acceptance criteria**: Integration tests use real ZeroMQ sockets with in-process
communication. Tests can send wire messages and verify routing through all 6 stages.
Response Path is testable end-to-end. Test setup/teardown is clean (no socket leaks).
Tests run in CI without Docker.
**Complexity**: L

### QA-05: Build plugin conformance test suite

**Role**: QA
**Description**: Create a reusable test suite that validates any plugin against its
manifest contract. Verify: manifest parses correctly, declared tools are callable, tool
argument schemas match handler expectations, risk levels are honored, and lifecycle
hooks work. Plugin authors can run conformance tests on their own plugins.
**Dependencies**: QA-01, ENG-04, ENG-07, ARCH-03
**Acceptance criteria**: Running conformance tests against a valid plugin passes.
Running against a broken plugin produces specific, actionable failures. Plugin authors
can run: `pnpm test:conformance -- plugins/my-plugin/`.
**Complexity**: M

---

## P2 — Features & Hardening

These tasks add the first real plugin, developer tooling, security hardening,
adversarial testing, and the Claude Code e2e test infrastructure.

### ENG-10: Implement memory plugin — data layer

**Role**: Engineer
**Description**: Build the SQLite schema and data access layer for the memory plugin:
entries table (typed: preference, fact, instruction, context, correction), FTS5
full-text search index, provenance tracking (source session, timestamp, group).
Migrations for schema creation.
**Dependencies**: ENG-08, ARCH-02
**Test requirements**: QA-01, QA-02 (SQLite test helpers). Test: CRUD operations, FTS5
search ranking, provenance auto-fill, supersession chain handling, purge of old
superseded entries.
**Acceptance criteria**: Memory entries can be stored, searched (FTS5), and deleted.
Entry types are enforced. Provenance fields are populated automatically. Search returns
ranked results. `PRAGMA journal_mode=WAL` set during init. `PRAGMA user_version`
checked — refuse to start if DB version > handler version. Superseded entry purge
runs during `initialize()`. Group name validation enforced at DB path construction.
**Complexity**: M

### ENG-11: Implement memory plugin — tool handlers

**Role**: Engineer
**Description**: Build the four memory tool handlers: `memory_store` (create entry),
`memory_search` (FTS5 query), `memory_brief` (summarize recent/relevant entries for
session start), `memory_delete` (remove entry by ID). Each validates arguments against
schema.
**Dependencies**: ENG-10, DX-01, ENG-07
**Test requirements**: QA-01, QA-02. Test each handler: valid args pass, invalid
rejected, rate limits enforced, response format matches spec.
**Acceptance criteria**: All four tools work end-to-end. Arguments are validated.
Responses match documented format. Handler-enforced rate limits: max 20
`memory_store`, 5 `supersedes`, 5 `memory_delete` per session. `behavioral` flag
derived from `type` (never agent-supplied). Provenance fields populated from envelope
(session_id, group, timestamp) — never from arguments.
**Complexity**: L

### ENG-12: Implement memory plugin — skill file

**Role**: Engineer
**Description**: Write the container-side skill markdown file that teaches Claude about
the memory tools. Document each tool's purpose, arguments, examples, and when to use
it. Follow the skill file conventions established by DX. Include `ipc` invocation
examples.
**Dependencies**: ENG-11, ENG-09
**Acceptance criteria**: Skill file accurately describes all four tools. Includes usage
examples with `ipc` invocations. Claude can invoke memory tools correctly when given
this skill file.
**Complexity**: S

### ENG-13: Implement memory brief hook

**Role**: Engineer
**Description**: Build the event-driven hook that fires on `agent.started` events.
When a new session begins, the memory plugin automatically runs `memory_brief` and
injects the result into the agent's context. This gives the agent relevant memories
without being asked.
**Dependencies**: ENG-11, ENG-01, ENG-06, DEVOPS-03
**Test requirements**: QA-01, QA-02, QA-09. Test: brief generation, behavioral/non-
behavioral sorting, newline stripping (all variants: `\r\n`, `\r`, Unicode U+2028,
U+2029), max_brief_entries limit (default 50), max_brief_chars limit (default 10000),
5-second timeout behavior (core-enforced), empty group produces no brief, superseded
entries excluded from brief.
**Acceptance criteria**: On session start, memory brief is generated and available to
the agent. Brief includes relevant entries for the session's group. Behavioral entries
sorted before non-behavioral with warning block. Newline stripping prevents markdown
injection. Config limits honored (whichever hit first). 5-second timeout is
core-enforced. Empty groups produce no brief (not an error). Superseded entries
excluded.
**Complexity**: M

### SEC-04: Implement group-level authorization

**Role**: Security
**Description**: Build the authorization layer that ensures plugins only receive
messages for their authorized groups. The core checks the session's group against the
plugin's allowed groups before routing. Prevent cross-group data access in multi-group
scenarios.
**Dependencies**: SEC-01, ENG-06
**Acceptance criteria**: A plugin registered for group A never receives messages from
group B. Authorization checks happen in the router before dispatch. Unauthorized
attempts are logged with full context.
**Complexity**: M

### SEC-05: Build security test suite

**Role**: Security / QA
**Description**: Create a dedicated security test suite covering: wire format fuzzing,
identity spoofing attempts, cross-group access, rate limit boundary testing, credential
leak detection. Enumerate specific fuzzing scenarios: oversized JSON payload (1MB+),
deeply nested JSON (100+ levels), Unicode edge cases in topic names, empty/null/
undefined values in every field, prototype pollution attempts (`__proto__`,
`constructor.prototype`, `toString`), path traversal in group names, concurrent
session isolation, ZeroMQ connection identity spoofing, shutdown race conditions
(messages during drain phase), ToolError instanceof manipulation, error message
information leakage.
**Dependencies**: QA-04, SEC-01, SEC-02, SEC-03
**Test requirements**: Run as `pnpm test:security`. Tagged separately from unit tests.
**Acceptance criteria**: All documented security boundaries have corresponding tests.
Each fuzzing scenario is tested. Spoofing attempts are provably blocked. Concurrent
sessions proven isolated. Tests run in CI on every push.
**Complexity**: L

### SEC-06: Implement memory entry security model

**Role**: Security
**Description**: Build the untrusted-by-default model for memory entries: behavioral
flags (derived from `type`, not agent-supplied), provenance tracking (immutable after
creation), read-side security gates (skepticism instructions for untrusted entries).
Cover: newline stripping completeness (all markdown injection variants including
Unicode line separators), content length enforcement with storage growth bounds,
supersedes chain depth limits, behavioral flag derivation integrity (wire format
cannot override), FTS5 ranking manipulation resistance.
**Dependencies**: ENG-10
**Acceptance criteria**: Memory entries have behavioral flags derived from type.
Provenance is immutable after creation. Read-side gates inject skepticism instructions.
Entries from different groups are isolated. All newline variants stripped. Supersedes
chain depth is bounded. Wire format cannot influence behavioral flag.
**Complexity**: M

### SEC-09: Implement supply chain security pipeline

**Role**: Security / DevOps
**Description**: Integrate dependency and supply chain security into CI: (1) `pnpm
audit --audit-level=high` on every push, (2) Socket.dev for supply chain risk
analysis (typosquatting, install scripts, network access in packages), (3) lockfile
integrity verification (ensure pnpm-lock.yaml matches package.json), (4) GitHub secret
scanning enabled on the repo. Block merges on critical/high vulnerabilities.
**Dependencies**: DEVOPS-02
**Acceptance criteria**: CI pipeline includes dependency scanning. Critical
vulnerabilities block merge. Secret scanning catches credential patterns in commits.
Lockfile integrity is verified.
**Complexity**: M

### SEC-11: Implement SQLite and FTS5 injection testing

**Role**: Security / QA
**Description**: Verify that all SQLite operations use parameterized queries and cannot
be injected. FTS5 has its own query syntax — test: (1) SQL injection through memory
content, tags, and search query fields, (2) FTS5 query syntax injection (NEAR, AND,
OR, column filters), (3) path traversal in group names used for SQLite file paths,
(4) PRAGMA injection attempts.
**Dependencies**: ENG-10, SEC-06
**Acceptance criteria**: All DB operations use parameterized queries (verified by code
review + Semgrep rule). FTS5 query injection attempts are neutralized. Group name
validation rejects traversal patterns. Tests cover each vector.
**Complexity**: M

### SEC-12: Build adversarial e2e security test framework

**Role**: Security / QA
**Description**: Build a framework for adversarial e2e testing that exercises the full
attack surface through real agent sessions. Scenarios: (1) prompt injection via inbound
message, (2) memory poisoning — store malicious behavioral instruction, verify brief
flags it, (3) identity spoofing via crafted wire messages, (4) tool enumeration —
invoke undeclared tools, (5) rate limit exhaustion — flood invocations, (6) credential
probing — check responses for leaked credentials, (7) container escape attempts —
access network, modify settings.json, execute arbitrary binaries.
**Dependencies**: SEC-05, QA-06, SEC-07, QA-08
**Test requirements**: Run as tagged `security-e2e` tests, separate from unit tests.
**Acceptance criteria**: Each adversarial scenario has an automated test. All attacks
are provably contained. Test report maps scenarios to defense layers. Tests run in CI
on merge to main.
**Complexity**: XL

### SEC-13: Implement audit log integrity and security

**Role**: Security
**Description**: Secure the audit log itself: (1) append-only (no modification/deletion
by plugins or handlers), (2) log entries include sequence numbers to detect tampering,
(3) log rotation with archive integrity, (4) audit log directory permissions prevent
container access, (5) sensitive data (credential patterns) never written to audit logs
even in error stack traces.
**Dependencies**: ENG-17, SEC-01
**Acceptance criteria**: Audit log cannot be modified after write. Tamper detection
catches deletions/modifications. Credential patterns are scrubbed from log entries.
Tests verify log integrity under normal and adversarial conditions.
**Complexity**: M

### SEC-14: Write custom Semgrep SAST rules

**Role**: Security / DevOps
**Description**: Write Carapace-specific Semgrep rules that encode security invariants
as code: (1) `no-identity-in-wire-format` — flag reading source/group/id from wire
input, (2) `require-additional-properties-false` — flag JSON Schema objects missing
it, (3) `parameterized-sqlite-queries` — flag string concatenation in query
construction, (4) `no-error-message-passthrough` — flag
`new ToolError({message: err.message})`, (5) `no-credentials-in-responses` — flag
env vars or config values in return objects, (6) `group-isolation` — flag direct DB
queries without group filter. Integrate into CI (blocks merge on findings).
**Dependencies**: DEVOPS-02
**Acceptance criteria**: At least 6 custom Semgrep rules running in CI. Violations
fail the build. Rules are documented with examples. False positives can be suppressed
via inline comments.
**Complexity**: M

### DEVOPS-05: Implement health check system

**Role**: DevOps
**Description**: Build `carapace doctor` that checks: Node.js version, pnpm
availability, Docker running, ZeroMQ library installed, SQLite available, plugin
directories valid, socket paths writable. Report clear pass/fail per check with fix
suggestions.
**Dependencies**: DX-02
**Acceptance criteria**: `carapace doctor` reports status of all dependencies. Failed
checks include actionable fix instructions. Exit code is non-zero if any check fails.
Works on macOS and Linux.
**Complexity**: M

### DEVOPS-06: Implement log aggregation

**Role**: DevOps
**Description**: Build structured logging for the core, plugins, and container output.
JSON-formatted logs with level, timestamp, component, and message. Route container
stdout/stderr to host logging. Support log level configuration.
**Dependencies**: ENG-03, DEVOPS-03
**Acceptance criteria**: All components log in structured JSON format. Container output
appears in host logs. Log levels are configurable (debug, info, warn, error). Logs
include component identification.
**Complexity**: M

### DEVOPS-09: Add Nix build output for host binary

**Role**: DevOps
**Description**: Extend `flake.nix` to include a `packages.default` output that builds
the host-side TypeScript into a deployable artifact (compiled JS + node_modules).
Currently the flake only defines a `devShell`. A build output enables `nix build` for
reproducible production builds.
**Dependencies**: ARCH-01
**Acceptance criteria**: `nix build` produces a runnable artifact. Output includes
compiled JS and pinned dependencies. Build is reproducible.
**Complexity**: M

### DEVOPS-11: Implement e2e test CI infrastructure

**Role**: DevOps / QA
**Description**: Build CI infrastructure for running Claude Code e2e tests: nightly
scheduled workflow, token/cost budget caps per run, result categorization (PASS,
DIFFERENT_PATH, REGRESSION, FLAKY, BUDGET_EXCEEDED), trend tracking across runs,
alerting on sustained pass-rate drops. These tests NEVER gate merges — they run on
schedule and produce reports.
**Dependencies**: DEVOPS-02, QA-08
**Acceptance criteria**: Nightly workflow runs e2e tests. Budget caps prevent runaway
costs. Results are categorized and stored. Trend dashboard shows pass-rate over time.
Alert fires if pass rate drops below threshold for N consecutive runs.
**Complexity**: L

### DX-03: Build plugin scaffolding CLI

**Role**: DX Advocate
**Description**: Add `carapace plugin create <name>` command that generates a new
plugin skeleton: `manifest.json` with placeholder tools, `handler.ts` with the
interface implemented, `skills/<name>.md` template, and a test file using the plugin
test SDK (DX-06). Interactive prompts for tool names and risk levels.
**Dependencies**: DX-01, DX-02, DX-06, ARCH-03
**Acceptance criteria**: `carapace plugin create my-plugin` creates a valid, buildable
plugin skeleton. Generated manifest validates. Generated handler compiles. Generated
test uses plugin test SDK and runs (fails per TDD — ready for implementation).
**Complexity**: M

### DX-04: Build message tracing / debug mode

**Role**: DX Advocate
**Description**: Add a debug mode that logs all messages flowing through the system:
wire messages received, envelopes constructed, routing decisions, plugin dispatch,
responses returned. Tap into ZeroMQ channels for real-time message inspection.
**Dependencies**: ENG-03, DX-02
**Acceptance criteria**: `carapace start --debug` shows all message flow. Messages are
pretty-printed with timestamps. Sensitive data (credentials) is redacted. Can filter
by topic or plugin.
**Complexity**: M

### DX-05: Write plugin authoring guide

**Role**: DX Advocate
**Description**: Create comprehensive documentation for plugin authors: manifest format
reference, handler interface guide, skill file conventions, testing guide (unit via
plugin test SDK, conformance via QA-05, integration via QA-04), and walkthroughs
building both the echo plugin (simple) and memory plugin (complex) from scratch.
**Dependencies**: ENG-12, DX-01, DX-03, DX-06, QA-05
**Acceptance criteria**: A developer unfamiliar with the codebase can build and test a
new plugin by following the guide. All code examples compile and work. Guide covers
error cases, debugging, and the full testing pyramid for plugins.
**Complexity**: M

### DX-07: Implement plugin hot reload / watch mode

**Role**: DX Advocate
**Description**: Add `carapace start --watch` that monitors `plugins/` for file
changes. On change: re-validate manifest, re-compile handler, re-register tools in
the router. Clear terminal output showing what was reloaded and success/failure.
**Dependencies**: DX-02, ENG-04
**Acceptance criteria**: Modifying a plugin handler and saving triggers automatic
reload within 2 seconds. Manifest errors during reload show actionable messages without
crashing the system.
**Complexity**: M

### DX-08: Build manifest validation CLI command

**Role**: DX Advocate
**Description**: Add standalone `carapace plugin validate [path]` that validates a
manifest without starting the system. Checks: JSON syntax, schema validity, tool name
uniqueness, `additionalProperties: false` on all argument schemas, skill file
existence, risk level warnings.
**Dependencies**: ARCH-03, DX-02
**Acceptance criteria**: `carapace plugin validate plugins/my-plugin/` returns
pass/fail with specific error messages. Exits non-zero on failure. Works without a
running core.
**Complexity**: S

### QA-06: Build container lifecycle integration tests

**Role**: QA
**Description**: Create integration tests that exercise the full container lifecycle:
spawn container, establish ZeroMQ connection, send tool invocations, receive responses,
and clean shutdown. These require Docker and run in CI but not in the normal unit test
suite.
**Dependencies**: QA-04, DEVOPS-03, ENG-05
**Test requirements**: Run as `pnpm test:e2e`. Docker-required, tagged separately.
**Acceptance criteria**: Tests cover: spawn, communication, graceful shutdown, forced
shutdown, stale/orphan cleanup. Tests are tagged to run separately from unit tests.
Tests clean up all containers on failure.
**Complexity**: L

### QA-07: Implement coverage reporting and gates

**Role**: QA
**Description**: Configure coverage collection (v8 via Vitest), set minimum coverage
thresholds, and add coverage gates to CI that block merges below thresholds. Generate
HTML coverage reports for local review.
**Dependencies**: QA-01, DEVOPS-02
**Acceptance criteria**: `pnpm test:coverage` generates reports. CI fails if coverage
drops below thresholds. Global: 80% line, 70% branch. Security-critical modules
(`src/core/router`, `src/core/validation`): 90% line, 80% branch. HTML reports are
generated for local review. Coverage excludes test files and type definitions.
**Complexity**: S

### QA-08: Build Claude Code e2e test infrastructure

**Role**: QA
**Description**: Build the test runner infrastructure for end-to-end tests driven by
Claude Code as an actual AI agent. These tests are non-deterministic — Claude Code
drives real agent sessions (spawn container, read skills, invoke tools via IPC, receive
responses). Infrastructure includes: scenario definition format (input prompt →
expected observable outcomes), semantic assertion library for non-deterministic outputs
(e.g., "tool X was invoked", "response contains concept Y", "no error codes
returned"), deterministic mock plugins with known behavior, timeout/retry logic for
flaky tests, structured test result collection and reporting, cost tracking per test.

**E2E test scenarios (minimum 10):**

1. Happy path tool invocation — agent calls tool, gets result
2. Multi-tool session — agent chains multiple tool calls
3. Error handling — agent receives VALIDATION_FAILED, responds appropriately
4. Rate limiting — agent hits limit, receives RATE_LIMITED with retry_after
5. Cross-group rejection — wrong group → UNAUTHORIZED
6. Malformed arguments — bad args → VALIDATION_FAILED → agent self-corrects
7. Session lifecycle — full spawn → communicate → graceful shutdown → cleanup
8. Memory brief injection — session starts with memory context, agent uses it
9. Plugin failure degradation — plugin fails init, agent discovers via get_session_info
10. High-risk tool confirmation — risk_level "high" triggers confirmation flow

**Dependencies**: QA-04, QA-06, DEVOPS-03, ENG-05, ENG-09, ENG-14
**Acceptance criteria**: A simple e2e scenario runs end-to-end. Tests assert on tool
invocations (which tools, what arguments) not exact output. Mock plugins provide
deterministic behavior. Test runner handles timeouts. Results are structured and
CI-reportable. Flaky test tolerance: tests pass 90%+ of runs.
**Complexity**: XL

### QA-11: Build performance benchmark suite

**Role**: QA
**Description**: Build performance benchmarks for critical paths: ZeroMQ message
throughput (messages/second through full pipeline), SQLite query latency (FTS5 search,
memory brief generation), rate limiter accuracy under concurrent load, container spawn
time, and plugin initialization time. Establish baseline metrics and fail CI if
performance regresses beyond thresholds.
**Dependencies**: QA-04, ENG-01, ENG-02, ENG-03, ENG-08
**Acceptance criteria**: Benchmarks cover: message throughput (>100 msg/s through
pipeline), FTS5 search (<50ms for 1000 entries), container spawn (<10s cold start),
rate limiter accuracy (±5% at boundary). Baselines are recorded. CI detects
regressions.
**Complexity**: L

---

## CI Pipeline Design

### Stage Architecture

```
┌─────────────────────────────────────────────────────────┐
│  STAGE 1: FAST CHECKS  (parallel, < 30s)                │
│  ├── oxlint (lint)                                      │
│  ├── prettier --check (format)                          │
│  ├── tsc --noEmit (type check)                          │
│  └── pnpm audit --audit-level=high (baseline deps)      │
│  Gate: All must pass.                                   │
├─────────────────────────────────────────────────────────┤
│  STAGE 2: UNIT TESTS + COVERAGE  (< 3 min)             │
│  ├── vitest run (all unit tests)                        │
│  ├── Coverage collection (v8 provider)                  │
│  └── Coverage gates:                                    │
│      Global: 80% line, 70% branch                       │
│      Security modules: 90% line, 80% branch             │
│  Gate: 100% tests pass + coverage thresholds met.       │
├─────────────────────────────────────────────────────────┤
│  STAGE 3: SECURITY SCANNING  (parallel, < 5 min)       │
│  ├── Semgrep (custom Carapace SAST rules)               │
│  ├── CodeQL (GitHub-native deep analysis)               │
│  └── Socket.dev (supply chain risk)                     │
│  Gate: Zero high/critical Semgrep + CodeQL findings.    │
│  Socket.dev is advisory (non-blocking).                 │
├─────────────────────────────────────────────────────────┤
│  STAGE 4: INTEGRATION + SECURITY TESTS  (< 5 min)      │
│  ├── ZeroMQ integration tests (QA-04)                   │
│  ├── Plugin conformance tests (QA-05)                   │
│  └── Security boundary tests (SEC-05)                   │
│  Gate: 100% pass.                                       │
├─────────────────────────────────────────────────────────┤
│  STAGE 5: CONTAINER TESTS  (on merge to main, < 15 min) │
│  ├── Container build + Trivy scan (DEVOPS-08)           │
│  ├── Container lifecycle tests (QA-06)                  │
│  └── Container security verification (SEC-07)           │
│  Gate: All pass. Trivy high/critical block.             │
├─────────────────────────────────────────────────────────┤
│  STAGE 6: E2E TESTS  (on merge to main, < 15 min)      │
│  └── Claude Code e2e scenarios (QA-08)                  │
│  Gate: 90% pass rate (non-deterministic tolerance).     │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│  SCHEDULED (not per-PR):                                │
│  ├── Nightly: Full Claude Code e2e suite + adversarial  │
│  │           security tests (SEC-12) with budget caps   │
│  ├── Weekly: OpenSSF Scorecard                          │
│  └── Weekly: Performance benchmark regression check     │
└─────────────────────────────────────────────────────────┘
```

### Quality Gates Summary

| Gate                | Tool          | Threshold            | Blocks Merge  |
| ------------------- | ------------- | -------------------- | :-----------: |
| Lint                | oxlint        | Zero errors          |      Yes      |
| Format              | prettier      | All files pass       |      Yes      |
| Types               | tsc --noEmit  | Zero errors          |      Yes      |
| Deps                | pnpm audit    | Zero high/critical   |      Yes      |
| Unit tests          | vitest        | 100% pass            |      Yes      |
| Coverage (global)   | v8            | 80% line, 70% branch |      Yes      |
| Coverage (security) | v8            | 90% line, 80% branch |      Yes      |
| Semgrep             | custom rules  | Zero high/critical   |      Yes      |
| CodeQL              | github-native | Zero high/critical   |      Yes      |
| Integration tests   | vitest        | 100% pass            |      Yes      |
| Security tests      | vitest        | 100% pass            |      Yes      |
| Container scan      | Trivy         | Zero high/critical   | Yes (on main) |
| Container tests     | vitest        | 100% pass            | Yes (on main) |
| E2E tests           | Claude Code   | 90% pass rate        | Yes (on main) |
| Supply chain        | Socket.dev    | Advisory             |      No       |
| OpenSSF             | Scorecard     | Score > 7            |      No       |

---

## Testing Pyramid

```
          /\
         /  \     E2E via Claude Code (QA-08)
        / 10 \    Non-deterministic, validates full system
       /------\
      /        \   Adversarial Security E2E (SEC-12)
     /  7 tests \  Prompt injection, memory poisoning, escape attempts
    /------------\
   /              \  Integration (QA-04, QA-05, QA-06, SEC-05, SEC-07)
  / ~50-100 tests  \ Real ZeroMQ, real containers, real validation pipeline
 /------------------\
/                    \  Unit Tests (TDD on every module)
/ Hundreds of tests    \ Every ENG/SEC/DX task has unit tests via strict TDD
/________________________\
```

### Plugin Author Testing Layers

1. **Unit tests** (Vitest + Plugin Test SDK DX-06): Test handler logic in isolation.
   `pnpm test -- plugins/my-plugin/`. Subsecond feedback.
2. **Conformance tests** (QA-05): Validate manifest contract.
   `pnpm test:conformance -- plugins/my-plugin/`
3. **Integration tests** (QA-04): Test through real ZeroMQ messaging pipeline.
   `pnpm test:integration -- plugins/my-plugin/`
4. **E2E tests** (QA-08): Full Claude Code session with plugin. Non-deterministic.
   `pnpm test:e2e -- plugins/my-plugin/`

---

## Dependency Graph (Critical Path)

```
ARCH-01 (bootstrap)
├── ARCH-02 (message types) ──┐
├── ARCH-03 (manifest schema) │
├── QA-01 (test framework)    │
├── DEVOPS-01 (Dockerfile)    │
├── DEVOPS-02 (CI pipeline)   │
└── ENG-08 (SQLite layer)     │  ← can start immediately
                               │
ENG-01 (PUB/SUB) ─────────────┤
ENG-02 (ROUTER/DEALER) ───────┤──── ENG-05 (IPC binary)
                               │     ↑ parallel with ENG-03!
                               ▼
                    ENG-03 (core router)
                         │
          ┌──────────────┼──────────────────────┐
          ▼              ▼                      ▼
    ENG-04           ENG-06                  SEC-02
  (plugin loader)  (session mgr)         (response sanitize)
      │                │                      │
      │           ┌────┴────┐                 │
      │           ▼         ▼                 ▼
      │      ENG-17     SEC-03          ENG-18
      │    (audit log) (rate limiter) (ToolError)
      │         │           │
      │         ▼           ▼
      │     ENG-14      SEC-01 (host-side validation)
      │   (intrinsic       │
      │    tools)     ┌────┼────────┐
      │               ▼    ▼        ▼
      │          SEC-04  ENG-15   SEC-08
      │        (group   (confirm  (DoS
      │         auth)    gate)   prevention)
      │
      ├── SEC-10 (manifest security)
      ├── ENG-09 (skill loader)
      │
      ▼
DEVOPS-03 (container lifecycle)
      │
      ├── DEVOPS-10 (permission lockdown)
      ├── ENG-19 (event-to-agent logic)
      │
      ▼
Full end-to-end session
      │
 ┌────┼────────┬─────────┐
 ▼    ▼        ▼         ▼
ENG-10 DX-03  QA-06    SEC-07
(memory (scaffold)(lifecycle (container
 data)  CLI)    tests)  security)
 │
 ▼
ENG-11 (memory tools) ──→ QA-08 (Claude Code e2e)
 │                              │
 ├── ENG-12 (skill file)        ▼
 └── ENG-13 (brief hook)   SEC-12 (adversarial e2e)
```

### Shortest Path to Working System

1. ARCH-01 → ARCH-02 → ENG-01 + ENG-02 → ENG-03 + ENG-05 (parallel) → ENG-04 +
   ENG-06 → DEVOPS-03
2. This gets you: project structure → message types → both ZeroMQ channels → router +
   IPC binary (parallel) → plugin loader + sessions → container lifecycle = **a running
   agent that can invoke tools**

### Parallel Work Streams from ARCH-01

These can all start immediately after ARCH-01:

- ARCH-02 + ARCH-03 (types and schemas)
- QA-01 + QA-03 + QA-09 + QA-10 (test infrastructure)
- DEVOPS-01 + DEVOPS-02 (container + CI)
- ENG-08 (SQLite layer — no messaging dependency)

---

## Task Summary

| Category  |  Count |     P0 |     P1 |     P2 |
| --------- | -----: | -----: | -----: | -----: |
| ARCH      |      3 |      3 |      0 |      0 |
| ENG       |     19 |      4 |      9 |      6 |
| SEC       |     14 |      0 |      5 |      9 |
| DEVOPS    |     11 |      2 |      5 |      4 |
| DX        |      8 |      0 |      3 |      5 |
| QA        |     11 |      5 |      2 |      4 |
| **Total** | **66** | **14** | **24** | **28** |
