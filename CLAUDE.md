# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Carapace is a security-first, plugin-driven personal AI agent framework built in TypeScript/Node.js. It runs Claude Code inside isolated containers with a ZeroMQ-based messaging system connecting to host-side plugins that hold credentials and interact with external services.

## Development Environment

Uses Nix Flakes for reproducible development. Enter the dev shell:

```bash
direnv allow          # loads .envrc → `use flake`
```

This provides: Node.js 22, pnpm, TypeScript, Docker/Docker Compose, ZeroMQ, SQLite, oxlint, prettier.

## Build & Quality Commands

```bash
pnpm install          # install dependencies
pnpm run build        # compile TypeScript
pnpm run lint         # oxlint
pnpm run format       # prettier
pnpm test             # run full test suite
pnpm test -- <path>   # run a single test file
```

## Architecture

### Trust Model

Two domains separated by a hard trust boundary:

- **Container (Untrusted)**: Claude Code + markdown skill files + `ipc` binary. No network, no host filesystem, no credentials. Read-only filesystem except workspace and ZeroMQ socket.
- **Host (Trusted)**: Core router + plugins + credentials store. Validates every message from container. Constructs message identity from session state (never trusts container claims).

### Core Principles

1. **Security by architecture** — VM-based container isolation is the primary boundary, not application-level controls.
2. **Plugins are local and independent** — Filesystem discovery in `plugins/`, no registry or marketplace. Plugins never depend on each other.
3. **Two halves make a whole** — Each plugin is a pair: host-side handler (TypeScript, holds credentials, executes tools) + container-side skill (markdown teaching Claude the available tools).
4. **Core owns no business logic** — Routes messages, enforces policy, manages container lifecycle. Everything else is a plugin.

### Messaging (ZeroMQ)

Two channels over Unix sockets:

| Channel | Pattern | Purpose |
|---------|---------|---------|
| Event Bus | PUB/SUB | External triggers that **start** sessions (email arrives, cron fires) |
| Request Channel | ROUTER/DEALER | Tool invocations **during** sessions (agent needs a result) |

### Wire Format (Container → Host)

Container sends only 3 fields: `topic`, `correlation`, `arguments`. Core constructs the full envelope (`id`, `version`, `type`, `source`, `group`, `timestamp`) from trusted session state. Zero overlap between wire and envelope fields prevents spoofing.

### Plugin Structure

```
plugins/{name}/
  manifest.json         # declares tools, hooks, config schema
  handler.ts            # host-side: holds credentials, executes tool logic
  skills/{name}.md      # container-side: teaches Claude about available tools
```

Tool risk levels: `"low"` (auto-execute) vs `"high"` (requires user confirmation). All schemas enforce `additionalProperties: false`.

### Data Storage

Host-side SQLite at `data/{feature}/{group}.sqlite`. Credentials never enter the container.

## TDD Discipline

This project follows strict Red-Green-Refactor TDD (see `.claude/tdd-guard/`):

- **Red**: Write ONE failing test. Must fail for the right reason.
- **Green**: Write MINIMAL code to pass. No anticipatory coding.
- **Refactor**: Only when tests are green. Types, abstractions, cleanup allowed; new behavior is not.

Incremental stubs: "not defined" → create stub, "not a function" → add method stub, assertion failure → implement minimal logic.

## Key Documentation

- `docs/ARCHITECTURE.md` — Full system design, messaging protocol, security model, error codes
- `docs/MEMORY_DRAFT.md` — Memory plugin design (typed entries, FTS5 search, provenance tracking)
- `docs/FUTURE_FEATURES.md` — Roadmap with tiered priorities and competitive analysis
- `docs/TASKS.md` — Master development task list generated by the planning team

## AI Planning Team

Six specialized roles for task generation and architectural review. Re-create with: `TeamCreate` named `carapace-planning`, then spawn each role as a teammate with `team_name: "carapace-planning"`. Each role has a persistent instruction file in `docs/team-roles/`.

| Role | Name | Focus |
|------|------|-------|
| Architect | `architect` | System decomposition, module boundaries, dependency ordering, interface contracts, critical path |
| DevOps | `devops` | Container runtime, CI/CD, Nix packaging, ZeroMQ socket lifecycle, health checks, deployment |
| Security | `security` | Trust boundaries, schema validation, credential isolation, rate limiting, prompt injection defense |
| DX Advocate | `dx-advocate` | Plugin authoring experience, CLI ergonomics, scaffolding, error messages, debugging tools |
| Software Engineer | `engineer` | Core implementation: router, IPC binary, plugin loader, messaging, SQLite, memory plugin |
| QA | `qa` | Test framework, TDD enforcement, integration harness, security testing, plugin conformance |

### Spawning a Teammate

```
Task tool with:
  subagent_type: "general-purpose"
  name: "{role-name}"
  team_name: "carapace-planning"
  prompt: "You are the {Role} on the Carapace planning team. Read your role file at docs/team-roles/{role-name}.md and the architecture docs, then proceed with your assigned task."
```
